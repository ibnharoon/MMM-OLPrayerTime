// Import necessary modules from selenium-webdriver for browser manipulation
const { Builder, By, until } = require('selenium-webdriver');

// Import exec and util for executing shell commands and util.promisify
const { exec } = require('child_process');
const util = require('util');
const Dayjs = require('dayjs');
const {
  initializeSeleniumDriver,
  convertTimeStringToDate,
  durationToString,
  generateTest
} = require('../lib/utils');
const {
  getElementText,
  getElementClass,
  calculateExpectedDate
} = require('../lib/ui');

// Convert exec to a promise-based function for async/await usage
const execAsync = util.promisify(exec);

// Non-prayer time that needs to be filter out
const nonPrayer = ['Sunrise', 'Midnight'];

let expect;

/*
 * Name: test02
 *
 * Purpose:
 * This test suite is designed to validate the functionality of a prayer time application
 * running in a Dockerized environment. The application displays 
 * prayer times along with the Hijri date. The goals are to ensure that:
 *   - The application correctly calculates and displays the prayer times and Hijri date.
 *   - The prayer time transitions happen accurately according to the specified times.
 *   - The application's front-end elements reflect the expected state changes at given times.
 * Each test simulates the system time to check the application's behavior at specific prayer
 * intervals, ensuring the application's reliability and accuracy throughout the day.
 * 
 * Strategy:
 * 2 docker container will be created for the prayer time application and selenium standalone instance.
 * The two docker instances will be started with system time set to 2 minutes before the prayer starts.
 * If the 2 instances are not up within a specified time, the tests will be skipped, otherwise for each prayer
 * it will test for existence of the time duration element with the duration string of 2m and the blinking
 * attribute is on. It will then wait until the next minute and check if the duration changes to 1m. It will 
 * then wait for the next minute where the current prayer changes to the next prayer, and the hijri date changes to the next day. In some cases where the 
 * are not actual prayer times (sunrise, midnight) the next prayer check will be skipped. The hijri date 
 * changes when the maghrib prayer starts.
 *
 * Steps:
 * - before: Sets up the testing environment by dynamically importing the Chai library for assertions,
 *   building Docker images with a specified 'fakeTime' to simulate the system time at different prayer times,
 *   and initializing the Selenium WebDriver for browser automation. This setup prepares the application
 *   in a controlled state for testing.
 * - after: Tears down the testing environment by quitting the Selenium WebDriver, shutting down the Docker
 *   environment, and removing the Docker images. This cleanup ensures that each test run starts with a fresh
 *   environment and prevents resource leaks.
 *
 */

/* Example of prayer timings for Leap year DOY: 366
    {
      "date": "2024-12-31T08:00:00.000Z",
      "hijri": "29 Jum 1446",
      "day": 366,
      "times": {
        "fajr": "6:04 am",
        "sunrise": "7:22 am",
        "dhuhr": "12:11 pm",
        "asr": "2:42 pm",
        "maghrib": "5:01 pm",
        "isha": "6:18 pm",
        "midnight": "12:11 am"
      }
    },
    {
      "date": "2025-01-01T08:00:00.000Z",
      "hijri": "1 Raj 1446",
      "day": 1,
      "times": {
        "fajr": "6:04 am",
        "sunrise": "7:22 am",
        "dhuhr": "12:11 pm",
        "asr": "2:43 pm",
        "maghrib": "5:01 pm",
        "isha": "6:18 pm",
        "midnight": "12:11 am"
      }
    },
*/

// Define the test scenarios and expected values for each prayer time
const tests = {
  // 'Maghrib': {
  //   'fakeTime': '@2024-12-31 16:59:00', // Time to set the system under test (2m before current prayer)
  //   'previousPrayer': 'Asr',            // Expected previous prayer
  //   'hijri': '29 Jum 1446',             // expected Hijri date
  //   'nextHijri': '1 Raj 1446',          // expected next Hijri date
  //   'nextPrayer': 'Isha'                // Expected next prayer
  // },
  // 'Isha': {
  //   'fakeTime': '@2024-12-31 18:16:00', // Time to set the system under test (2m before current prayer)
  //   'previousPrayer': 'Maghrib',        // Expected previous prayer
  //   'hijri': '1 Raj 1446',              // expected Hijri date
  //   'nextHijri': '1 Raj 1446',          // expected next Hijri date
  //   'nextPrayer': 'Midnight'            // Expected next prayer
  // },
  // 'Midnight': {
  //   'fakeTime': '@2025-01-01 00:09:00',
  //   'previousPrayer': 'Isha',
  //   'hijri': '1 Raj 1446',
  //   'nextHijri': '1 Raj 1446',          // expected next Hijri date
  //   'nextPrayer': 'Fajr'
  // },
  // 'Fajr': {
  //   'fakeTime': '@2025-01-01 06:02:00', // Time to set the system under test (2m before current prayer)
  //   'previousPrayer': 'Midnight',       // Expected previous prayer
  //   'hijri': '1 Raj 1446',              // expected Hijri date
  //   'nextHijri': '1 Raj 1446',          // expected next Hijri date
  //   'nextPrayer': 'Sunrise'             // Expected next prayer
  // }
  'Non-leap': {
    'Date': '2025-12-31'
  },
  // 'Leap': {
  //  'Date': '2024-12-31'
  //}
};

const stages = [
  {
    min: 2,
    delay: 0,
    blink: true,
    msg: '2m before'
  },
  {
    min: 1,
    delay: 60000,
    blink: true,
    msg: '1m before'
  },
  {
    min: 0,
    delay: 70000,
    blink: false,
    msg: 'on'
  }
];

// Iterate over each test scenario to define Mocha tests
Object.entries(tests).forEach((test) => {
  const [scenario, date] = test;
  const rdate = new Dayjs(date['Date'], 'YYYY-MM-DD');
  const testscenarios = generateTest(rdate);
  //console.log('test: ' + JSON.stringify(testscenarios));

  Object.entries(testscenarios).forEach(([currentPrayer, testscenario]) => {
    //console.log(JSON.stringify(testscenario) + ', currentPrayer: ' + JSON.stringify(currentPrayer));
    const fakeTime = testscenario['fakeTime'];
    const previousPrayer = testscenario['previousPrayer'];
    const expectedHijriDate = testscenario['hijri'];
    const nextHijri = testscenario['nextHijri'];
    const nextPrayer = testscenario['nextPrayer'];
    var interrupt = () => {};
    throw interrupt;

    describe('02 Test scenario for end of a leap year', function () {
      this.timeout(3600000);

      let driver = null; // Declare Selenium WebDriver
      before(async () => {
        // Setup actions before each test suite
        const chai = await import('chai');  // Dynamically import Chai for assertions
        expect = chai.expect;               // Assign expect for assertions
        console.log(`Building Docker images with time 2m before ${currentPrayer}`);

        // Build and start Docker containers configured to 2m before the current prayer starts
        await execAsync(`docker build --build-arg "FAKETIME=${fakeTime}" -t mm-magicmirror . --file Dockerfile-mm`);
        await execAsync(`docker build --build-arg "FAKETIME=${fakeTime}" -t mm-selenium . --file Dockerfile-selenium`);
        await execAsync('docker compose up -d');  // Start the Docker environment

        const seleniumServerUrl = 'http://172.20.5.2:4444/wd/hub';
        driver = await initializeSeleniumDriver(seleniumServerUrl);  // Wait for the selenium server to be fully up and running
        // Assert that driver is initialized successfully
        expect(driver, 'Selenium server did not start within the expected time.').to.not.be.null;

        await driver.get('http://172.20.5.1:8080');

        // Wait for the element to be present in the DOM and assert its presence
        var durationElement = await driver.wait(until.elementLocated(By.id('ptimeDOM-premain')), 10000);
        expect(durationElement, 'Span element with id "ptimeDOM-premain" should be present').to.exist;
      });

      after(async () => {
        // Cleanup actions after each test suite
        if (driver !== null) {
          await driver.quit();  // Quit the Selenium WebDriver
        }

        await execAsync('docker compose down'); // Stop the Docker environment

        console.log(`Cleaning up Docker images`);
        await execAsync(`docker rmi mm-magicmirror`); // Remove Docker images
        await execAsync(`docker rmi mm-selenium`);
      });

      Object.entries(stages).forEach((stage) => {
        //console.log('stage: ' + JSON.stringify(stage));
        var expectedDate;
        var addMin = parseInt(stage[0]);
        var min = stage[1].min;
        var blink = stage[1].blink;
        var delay = stage[1].delay;
        var msg = stage[1].msg;

        describe('Validate times ' + msg + ' ' + currentPrayer + ' prayer', function () {

          before(function (done) {
            setTimeout(function () {
              expectedDate = calculateExpectedDate(fakeTime, addMin);
              done();
            }, delay);
          }
          );

          it('The current date should be correct', async () => {
            const edatestr = expectedDate.format('YYYY-MM-DD hh:mm A');
            var actualDate = await getElementText(driver, 'currentTime');
            expect(actualDate, `Expected date '${edatestr}' but found '${actualDate}'`).to.equal(edatestr);
          });

          it('The duration field should ' + (blink ? '' : 'not ') + 'blink', async () => {
            const actualClasses = await getElementClass(driver, 'ptimeDOM-premain');
            const expectedClasses = 'tickercontent' + (blink ? ' blink' : '');
            expect(actualClasses, `Expected class '${expectedClasses}' but found '${actualClasses}'`).to.equal(expectedClasses);
          });

          if (min > 0) {
            it('The current hijri date should be correct', async () => {
              const actualDate = await getElementText(driver, 'ptimeDOM-table-td-date');
              expect(actualDate, `Expected hijri date '${expectedHijriDate}' but found '${actualDate}'`).to.equal(expectedHijriDate);
            });

            it('The next prayer message should be "' + currentPrayer + ' ' + min + 'm"', async () => {
              var actualDur = await getElementText(driver, 'ptimeDOM-premain');
              expectedDur = currentPrayer + ' ' + min + 'm';
              expect(actualDur, `Expected duration '${expectedDur}' but found '${actualDur}'`).to.equal(expectedDur);
            });

            if (!nonPrayer.includes(currentPrayer)) {
              // current prayer should not be highlighted
            }
          } else {
            it('The next hijri date should be correct', async () => {
              const actualDate = await getElementText(driver, 'ptimeDOM-table-td-date');
              expect(actualDate, `Expected hijri date '${nextHijri}' but found '${actualDate}'`).to.equal(nextHijri);
            });

            if (!nonPrayer.includes(currentPrayer)) {
              // current prayer should be highlighted
            }

            if (!nonPrayer.includes(nextPrayer)) {
              it('The next prayer message should be correct', async () => {
                var actualDur = await getElementText(driver, 'ptimeDOM-premain');
                const prayerTimeString = await getElementText(driver, 'ptimeDOM-table-td-ptime-' + nextPrayer.toLowerCase());
                var currentDateString = await getElementText(driver, 'currentTime');
                var endDate = convertTimeStringToDate(prayerTimeString, currentDateString, nextPrayer);
                expectedDur = nextPrayer + ' ' + durationToString(expectedDate, endDate);
                expect(actualDur, `Expected duration '${expectedDur}' but found '${actualDur}'`).to.equal(expectedDur);
              });
            }
          }

          if (!nonPrayer.includes(previousPrayer)) {

          }

          if (!nonPrayer.includes(currentPrayer)) {

          }
        });
      });
    });
  });
});
